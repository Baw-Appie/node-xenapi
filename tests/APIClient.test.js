// Generated by CoffeeScript 1.8.0
(function() {
  var chai, chaiAsPromised, expect, sinon, sinonChai;

  chai = require('chai');

  chaiAsPromised = require('chai-as-promised');

  expect = chai.expect;

  sinon = require('sinon');

  sinonChai = require('sinon-chai');

  chai.use(sinonChai);

  chai.use(chaiAsPromised);

  describe("APIClient", function() {
    var APIClient, xmlrpc, xmlrpcclient;
    xmlrpc = void 0;
    xmlrpcclient = void 0;
    APIClient = void 0;
    beforeEach(function() {
      xmlrpc = {
        createClient: function() {
          return xmlrpcclient;
        }
      };
      xmlrpcclient = {
        methodCall: function() {}
      };
      return APIClient = require('../lib/APIClient');
    });
    describe("constructor", function() {
      var createClientStub;
      createClientStub = null;
      beforeEach(function() {
        return createClientStub = sinon.stub(xmlrpc, "createClient", function() {
          return null;
        });
      });
      afterEach(function() {
        return createClientStub.restore();
      });
      it("should throw unless xmlrpc is provided", function() {
        return expect(function() {
          return new APIClient();
        }).to["throw"](/Must provide xmlrpc/);
      });
      it("should throw unless options are provided", function() {
        return expect(function() {
          return new APIClient(xmlrpc);
        }).to["throw"](/Must provide options/);
      });
      it("should throw unless `host` is provided in options", function() {
        return expect(function() {
          return new APIClient(xmlrpc, {});
        }).to["throw"](/Must provide `host` in options/);
      });
      it("should throw unless `port` is provided in options", function() {
        return expect(function() {
          return new APIClient(xmlrpc, {
            host: "test"
          });
        }).to["throw"](/Must provide `port` in options/);
      });
      return it("should construct an xmlrpc-client using provided options", function() {
        var options;
        options = {
          host: "testHost",
          port: 80
        };
        new APIClient(xmlrpc, options);
        return expect(createClientStub).to.have.been.calledWith(options);
      });
    });
    return describe("request", function() {
      var apiClient, methodCallStub;
      apiClient = void 0;
      methodCallStub = void 0;
      beforeEach(function() {
        var options;
        options = {
          host: "testHost",
          port: 80
        };
        methodCallStub = sinon.stub(xmlrpcclient, "methodCall", function(method, args, cb) {
          return cb(null, {
            Value: ""
          });
        });
        return apiClient = new APIClient(xmlrpc, options);
      });
      afterEach(function() {
        return methodCallStub.restore();
      });
      it("should pass on provided parameters to xmlrpc client", function() {
        var methodArgs, methodName;
        methodName = "testModule.testMethod";
        methodArgs = ["arrayArg1", "arrayArg2"];
        apiClient.request(methodName, methodArgs);
        return expect(methodCallStub).to.have.been.calledWith(methodName, methodArgs);
      });
      it("should resolve on successful requests", function(done) {
        var promise;
        promise = apiClient.request();
        return expect(promise).to.eventually.be.fulfilled.and.notify(done);
      });
      return it("should reject on failed requests", function(done) {
        var promise;
        methodCallStub.restore();
        methodCallStub = sinon.stub(xmlrpcclient, "methodCall", function(method, args, cb) {
          return cb({
            error: ""
          }, null);
        });
        promise = apiClient.request();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
    });
  });

}).call(this);
