// Generated by CoffeeScript 1.10.0
(function() {
  var Promise, chai, chaiAsPromised, expect, sinon, sinonChai;

  chai = require('chai');

  chaiAsPromised = require('chai-as-promised');

  expect = chai.expect;

  sinon = require('sinon');

  sinonChai = require('sinon-chai');

  Promise = require('bluebird');

  chai.use(sinonChai);

  chai.use(chaiAsPromised);

  describe("VM", function() {
    var VM, XenAPI, session;
    session = void 0;
    VM = void 0;
    XenAPI = void 0;
    beforeEach(function() {
      session = {
        request: function() {}
      };
      VM = require('../../lib/Models/VM');
      return XenAPI = {
        'session': session
      };
    });
    describe("constructor", function() {
      var opaqueRef, validVM;
      validVM = void 0;
      opaqueRef = void 0;
      beforeEach(function() {
        validVM = {
          uuid: 'abcd',
          is_a_template: false,
          is_control_domain: false
        };
        return opaqueRef = 'OpaqueRef:abcd';
      });
      afterEach(function() {});
      it("should throw unless session is provided", function() {
        return expect(function() {
          return new VM();
        }).to["throw"](/Must provide `session`/);
      });
      it("should throw unless vm is provided", function() {
        return expect(function() {
          return new VM(session);
        }).to["throw"](/Must provide `vm`/);
      });
      it("should throw unless opaqueRef is provided", function() {
        return expect(function() {
          return new VM(session, validVM);
        }).to["throw"](/Must provide `opaqueRef`/);
      });
      it("should throw unless XenAPI is provided", function() {
        return expect(function() {
          return new VM(session, validVM, "OpaqueRef");
        }).to["throw"](/Must provide `xenAPI`/);
      });
      it("should throw if vm does not have a UUID", function() {
        return expect(function() {
          return new VM(session, {
            is_a_template: false,
            is_control_domain: false
          }, opaqueRef, XenAPI);
        }).to["throw"](/`vm` does not describe a valid VM/);
      });
      it("should throw if vm is a template", function() {
        return expect(function() {
          return new VM(session, {
            uuid: 'abcd',
            is_a_template: true,
            is_control_domain: false
          }, opaqueRef, XenAPI);
        }).to["throw"](/`vm` does not describe a valid VM/);
      });
      it("should throw if vm is a control domain", function() {
        return expect(function() {
          return new VM(session, {
            uuid: 'abcd',
            is_a_template: false,
            is_control_domain: true
          }, opaqueRef, XenAPI);
        }).to["throw"](/`vm` does not describe a valid VM/);
      });
      it("should assign the passed uuid to `uuid` property", function() {
        var vm, vmTemplate;
        vmTemplate = validVM;
        vmTemplate.uuid = 'abcd';
        vm = new VM(session, vmTemplate, opaqueRef, XenAPI);
        return expect(vm.uuid).to.equal(vmTemplate.uuid);
      });
      it("should assign the passed label to `name` property", function() {
        var vm, vmTemplate;
        vmTemplate = validVM;
        vmTemplate.name_label = 'abcd';
        vm = new VM(session, vmTemplate, opaqueRef, XenAPI);
        return expect(vm.name).to.equal(vmTemplate.name_label);
      });
      it("should assign the passed description to `description` property", function() {
        var vm, vmTemplate;
        vmTemplate = validVM;
        vmTemplate.name_description = 'abcd';
        vm = new VM(session, vmTemplate, opaqueRef, XenAPI);
        return expect(vm.description).to.equal(vmTemplate.name_description);
      });
      it("should set the `xenToolsInstalled` property based on whether guest_metrics are available", function() {
        var vm, vmTemplate;
        vmTemplate = validVM;
        vmTemplate.guest_metrics = 'OpaqueRef:NULL';
        vm = new VM(session, vmTemplate, opaqueRef, XenAPI);
        expect(vm.xenToolsInstalled).to.equal(false);
        vmTemplate.guest_metrics = 'OpaqueRef:abcd';
        vm = new VM(session, vmTemplate, opaqueRef, XenAPI);
        return expect(vm.xenToolsInstalled).to.equal(true);
      });
      return it("should assign the passed power state to `powerState` property", function() {
        var vm, vmTemplate;
        vmTemplate = validVM;
        vmTemplate.power_state = 'abcd';
        vm = new VM(session, vmTemplate, opaqueRef, XenAPI);
        return expect(vm.powerState).to.equal(vmTemplate.power_state);
      });
    });
    describe("refreshPowerState()", function() {
      var opaqueRef, requestStub, vm;
      opaqueRef = void 0;
      vm = void 0;
      requestStub = void 0;
      beforeEach(function() {
        var validVM;
        validVM = {
          uuid: 'abcd',
          is_a_template: false,
          is_control_domain: false
        };
        opaqueRef = 'OpaqueRef:abcd';
        vm = new VM(session, validVM, opaqueRef, XenAPI);
        return requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve();
          });
        });
      });
      afterEach(function() {});
      it("should call VM.get_power_state on the API", function(done) {
        return vm.refreshPowerState().then(function() {
          expect(requestStub).to.have.been.calledWith("VM.get_power_state");
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should pass the OpaqueRef of the VM to the API", function(done) {
        return vm.refreshPowerState().then(function() {
          expect(requestStub).to.have.been.calledWith(sinon.match.any, [opaqueRef]);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should reject if the API call fails", function(done) {
        var promise;
        requestStub.restore();
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return reject();
          });
        });
        promise = vm.refreshPowerState();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should resolve if the API call is successfull", function(done) {
        var promise;
        promise = vm.refreshPowerState();
        return expect(promise).to.eventually.be.fulfilled.and.notify(done);
      });
      it("should resolve with the latest power state of the VM", function(done) {
        requestStub.restore();
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Suspended");
          });
        });
        return vm.refreshPowerState().then(function(powerState) {
          expect(powerState).to.equal("Suspended");
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      return it("should update the VM to the latest power state", function(done) {
        requestStub.restore();
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Suspended");
          });
        });
        return vm.refreshPowerState().then(function() {
          expect(vm.powerState).to.equal("Suspended");
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
    });
    describe("pause()", function() {
      var opaqueRef, refreshPowerStateStub, requestStub, vm;
      opaqueRef = void 0;
      vm = void 0;
      requestStub = void 0;
      refreshPowerStateStub = void 0;
      beforeEach(function() {
        var validVM;
        validVM = {
          uuid: 'abcd',
          is_a_template: false,
          is_control_domain: false
        };
        opaqueRef = 'OpaqueRef:abcd';
        vm = new VM(session, validVM, opaqueRef, XenAPI);
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve();
          });
        });
        return refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Running");
          });
        });
      });
      afterEach(function() {
        requestStub.restore();
        return refreshPowerStateStub.restore();
      });
      it("should initially refresh the powerState of the VM", function(done) {
        return vm.pause().then(function() {
          expect(refreshPowerStateStub).to.have.been.calledOnce;
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should reject if the powerState of the VM is `Paused`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Paused");
          });
        });
        promise = vm.pause();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should reject if the powerState of the VM is `Suspended`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Suspended");
          });
        });
        promise = vm.pause();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should reject if the powerState of the VM is `Halted`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Halted");
          });
        });
        promise = vm.pause();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should resolve if the powerState of the VM is `Running`", function(done) {
        var promise;
        promise = vm.pause();
        return expect(promise).to.eventually.be.fulfilled.and.notify(done);
      });
      it("should call `VM.pause` on the API", function(done) {
        return vm.pause().then(function() {
          expect(requestStub).to.have.been.calledWith("VM.pause");
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      return it("should pass OpaqueRef for the VM to the API", function(done) {
        return vm.pause().then(function() {
          expect(requestStub).to.have.been.calledWith(sinon.match.any, [opaqueRef]);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
    });
    describe("unpause()", function() {
      var opaqueRef, refreshPowerStateStub, requestStub, vm;
      opaqueRef = void 0;
      vm = void 0;
      requestStub = void 0;
      refreshPowerStateStub = void 0;
      beforeEach(function() {
        var validVM;
        validVM = {
          uuid: 'abcd',
          is_a_template: false,
          is_control_domain: false
        };
        opaqueRef = 'OpaqueRef:abcd';
        vm = new VM(session, validVM, opaqueRef, XenAPI);
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve();
          });
        });
        return refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Paused");
          });
        });
      });
      afterEach(function() {
        requestStub.restore();
        return refreshPowerStateStub.restore();
      });
      it("should initially refresh the powerState of the VM", function(done) {
        return vm.unpause().then(function() {
          expect(refreshPowerStateStub).to.have.been.calledOnce;
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should reject if the powerState of the VM is `Running`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Running");
          });
        });
        promise = vm.unpause();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should reject if the powerState of the VM is `Suspended`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Suspended");
          });
        });
        promise = vm.unpause();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should reject if the powerState of the VM is `Halted`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Halted");
          });
        });
        promise = vm.unpause();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should resolve if the powerState of the VM is `Paused`", function(done) {
        var promise;
        promise = vm.unpause();
        return expect(promise).to.eventually.be.fulfilled.and.notify(done);
      });
      it("should call `VM.unpause` on the API", function(done) {
        return vm.unpause().then(function() {
          expect(requestStub).to.have.been.calledWith("VM.unpause");
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      return it("should pass OpaqueRef for the VM to the API", function(done) {
        return vm.unpause().then(function() {
          expect(requestStub).to.have.been.calledWith(sinon.match.any, [opaqueRef]);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
    });
    describe("suspend()", function() {
      var opaqueRef, refreshPowerStateStub, requestStub, vm;
      opaqueRef = void 0;
      vm = void 0;
      requestStub = void 0;
      refreshPowerStateStub = void 0;
      beforeEach(function() {
        var validVM;
        validVM = {
          uuid: 'abcd',
          is_a_template: false,
          is_control_domain: false
        };
        opaqueRef = 'OpaqueRef:abcd';
        vm = new VM(session, validVM, opaqueRef, XenAPI);
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve();
          });
        });
        return refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Running");
          });
        });
      });
      afterEach(function() {
        requestStub.restore();
        return refreshPowerStateStub.restore();
      });
      it("should initially refresh the powerState of the VM", function(done) {
        return vm.suspend().then(function() {
          expect(refreshPowerStateStub).to.have.been.calledOnce;
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should reject if the powerState of the VM is `Paused`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Paused");
          });
        });
        promise = vm.suspend();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should reject if the powerState of the VM is `Suspended`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Suspended");
          });
        });
        promise = vm.suspend();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should reject if the powerState of the VM is `Halted`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Halted");
          });
        });
        promise = vm.suspend();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should resolve if the powerState of the VM is `Running`", function(done) {
        var promise;
        promise = vm.suspend();
        return expect(promise).to.eventually.be.fulfilled.and.notify(done);
      });
      it("should call `VM.suspend` on the API", function(done) {
        return vm.suspend().then(function() {
          expect(requestStub).to.have.been.calledWith("VM.suspend");
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      return it("should pass OpaqueRef for the VM to the API", function(done) {
        return vm.suspend().then(function() {
          expect(requestStub).to.have.been.calledWith(sinon.match.any, [opaqueRef]);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
    });
    return describe("resume()", function() {
      var opaqueRef, refreshPowerStateStub, requestStub, vm;
      opaqueRef = void 0;
      vm = void 0;
      requestStub = void 0;
      refreshPowerStateStub = void 0;
      beforeEach(function() {
        var validVM;
        validVM = {
          uuid: 'abcd',
          is_a_template: false,
          is_control_domain: false
        };
        opaqueRef = 'OpaqueRef:abcd';
        vm = new VM(session, validVM, opaqueRef, XenAPI);
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve();
          });
        });
        return refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Suspended");
          });
        });
      });
      afterEach(function() {
        requestStub.restore();
        return refreshPowerStateStub.restore();
      });
      it("should initially refresh the powerState of the VM", function(done) {
        return vm.resume().then(function() {
          expect(refreshPowerStateStub).to.have.been.calledOnce;
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should reject if the powerState of the VM is `Paused`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Paused");
          });
        });
        promise = vm.resume();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should reject if the powerState of the VM is `Running`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Running");
          });
        });
        promise = vm.resume();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should reject if the powerState of the VM is `Halted`", function(done) {
        var promise;
        refreshPowerStateStub.restore();
        refreshPowerStateStub = sinon.stub(vm, "refreshPowerState", function() {
          return new Promise(function(resolve, reject) {
            return resolve("Halted");
          });
        });
        promise = vm.resume();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should resolve if the powerState of the VM is `Suspended`", function(done) {
        var promise;
        promise = vm.resume();
        return expect(promise).to.eventually.be.fulfilled.and.notify(done);
      });
      it("should call `VM.resume` on the API", function(done) {
        return vm.resume().then(function() {
          expect(requestStub).to.have.been.calledWith("VM.resume");
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should pass OpaqueRef for the VM to the API", function(done) {
        return vm.resume().then(function() {
          expect(requestStub).to.have.been.calledWith(sinon.match.any, [opaqueRef, sinon.match.any, sinon.match.any]);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should pass `false` as the default value for `start_paused` to the API", function(done) {
        return vm.resume().then(function() {
          expect(requestStub).to.have.been.calledWith(sinon.match.any, [sinon.match.any, false, sinon.match.any]);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      return it("should pass `false` as the default value for `force` to the API", function(done) {
        return vm.resume().then(function() {
          expect(requestStub).to.have.been.calledWith(sinon.match.any, [sinon.match.any, sinon.match.any, false]);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
    });
  });

}).call(this);
