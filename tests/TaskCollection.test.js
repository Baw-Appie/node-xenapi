// Generated by CoffeeScript 1.9.1
(function() {
  var Promise, chai, chaiAsPromised, expect, sinon, sinonChai;

  chai = require('chai');

  chaiAsPromised = require('chai-as-promised');

  expect = chai.expect;

  sinon = require('sinon');

  sinonChai = require('sinon-chai');

  Promise = require('bluebird');

  chai.use(sinonChai);

  chai.use(chaiAsPromised);

  describe("TaskCollection", function() {
    var Task, TaskCollection, XenAPI, session;
    session = void 0;
    TaskCollection = void 0;
    Task = void 0;
    XenAPI = void 0;
    beforeEach(function() {
      session = {
        request: function() {}
      };
      TaskCollection = require('../lib/TaskCollection');
      Task = require('../lib/Models/Task');
      return XenAPI = {
        'session': session
      };
    });
    describe("constructor", function() {
      beforeEach(function() {});
      afterEach(function() {});
      it("should throw unless session is provided", function() {
        return expect(function() {
          return new TaskCollection();
        }).to["throw"](/Must provide session/);
      });
      it("should throw unless Task is provided", function() {
        return expect(function() {
          return new TaskCollection(session);
        }).to["throw"](/Must provide Task/);
      });
      return it("should throw unless XenAPI is provided", function() {
        return expect(function() {
          return new TaskCollection(session, Task);
        }).to["throw"](/Must provide xenAPI/);
      });
    });
    return describe("list()", function(done) {
      var requestStub, taskCollection;
      requestStub = void 0;
      taskCollection = void 0;
      beforeEach(function() {
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve([]);
          });
        });
        return taskCollection = new TaskCollection(session, Task, XenAPI);
      });
      afterEach(function() {
        return requestStub.restore();
      });
      it("should call `task.get_all_records` on the API", function(done) {
        return taskCollection.list().then(function() {
          expect(requestStub).to.have.been.calledWith("task.get_all_records");
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should resolve if the API call is successful", function(done) {
        var promise;
        promise = taskCollection.list();
        return expect(promise).to.eventually.be.fulfilled.and.notify(done);
      });
      it("should reject if the API call resolves with undefined", function(done) {
        var promise;
        requestStub.restore();
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve();
          });
        });
        promise = taskCollection.list();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should reject if the API call fails", function(done) {
        var promise;
        requestStub.restore();
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return reject();
          });
        });
        promise = taskCollection.list();
        return expect(promise).to.eventually.be.rejected.and.notify(done);
      });
      it("should resolve with an empty array if the API returns nothing", function(done) {
        return taskCollection.list().then(function(tasks) {
          expect(tasks).to.deep.equal([]);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      it("should return instances of Task", function(done) {
        var validTask;
        validTask = {
          uuid: 'abcd',
          name_label: "test123",
          created: "Thu Jan 01 1970 00:00:00 GMT+0000 (GMT)",
          allowed_operations: [],
          status: "pending"
        };
        requestStub.restore();
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve({
              'abcd': validTask
            });
          });
        });
        return taskCollection.list().then(function(tasks) {
          expect(tasks[0]).to.be.an["instanceof"](Task);
          expect(tasks[0]).to.not.be.an["instanceof"](TaskCollection);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
      return it("should not return Tasks that fail validation", function(done) {
        var invalidTask;
        invalidTask = {
          uuid: 'abcd'
        };
        requestStub.restore();
        requestStub = sinon.stub(session, "request", function() {
          return new Promise(function(resolve, reject) {
            return resolve({
              'abcd': invalidTask
            });
          });
        });
        return taskCollection.list().then(function(tasks) {
          expect(tasks).to.deep.equal([]);
          return done();
        })["catch"](function(e) {
          return done(e);
        });
      });
    });
  });

}).call(this);
